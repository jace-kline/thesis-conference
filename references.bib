@article{bib:type-inference-executables,
    author = {Caballero, Juan and Lin, Zhiqiang},
    title = {Type Inference on Executables},
    year = {2016},
    issue_date = {May 2016},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {48},
    number = {4},
    issn = {0360-0300},
    url = {https://doi.org/10.1145/2896499},
    doi = {10.1145/2896499},
    abstract = {In many applications, source code and debugging symbols of a target program are not available, and the only thing that we can access is the program executable. A fundamental challenge with executables is that, during compilation, critical information such as variables and types is lost. Given that typed variables provide fundamental semantics of a program, for the last 16 years, a large amount of research has been carried out on binary code type inference, a challenging task that aims to infer typed variables from executables (also referred to as binary code). In this article, we systematize the area of binary code type inference according to its most important dimensions: the applications that motivate its importance, the approaches used, the types that those approaches infer, the implementation of those approaches, and how the inference results are evaluated. We also discuss limitations, underdeveloped problems and open challenges, and propose further applications.},
    journal = {ACM Comput. Surv.},
    month = {may},
    articleno = {65},
    numpages = {35},
    keywords = {program executables, binary code analysis, Type inference}
}

@inproceedings{bib:stateformer,
    author = {Pei, Kexin and Guan, Jonas and Broughton, Matthew and Chen, Zhongtian and Yao, Songchen and Williams-King, David and Ummadisetty, Vikas and Yang, Junfeng and Ray, Baishakhi and Jana, Suman},
    title = {StateFormer: Fine-Grained Type Recovery from Binaries Using Generative State Modeling},
    year = {2021},
    isbn = {9781450385626},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3468264.3468607},
    doi = {10.1145/3468264.3468607},
    abstract = {Binary type inference is a critical reverse engineering task supporting many security applications, including vulnerability analysis, binary hardening, forensics, and decompilation. It is a difficult task because source-level type information is often stripped during compilation, leaving only binaries with untyped memory and register accesses. Existing approaches rely on hand-coded type inference rules defined by domain experts, which are brittle and require nontrivial effort to maintain and update. Even though machine learning approaches have shown promise at automatically learning the inference rules, their accuracy is still low, especially for optimized binaries. We present StateFormer, a new neural architecture that is adept at accurate and robust type inference. StateFormer follows a two-step transfer learning paradigm. In the pretraining step, the model is trained with Generative State Modeling (GSM), a novel task that we design to teach the model to statically approximate execution effects of assembly instructions in both forward and backward directions. In the finetuning step, the pretrained model learns to use its knowledge of operational semantics to infer types. We evaluate StateFormer's performance on a corpus of 33 popular open-source software projects containing over 1.67 billion variables of different types. The programs are compiled with GCC and LLVM over 4 optimization levels O0-O3, and 3 obfuscation passes based on LLVM. Our model significantly outperforms state-of-the-art ML-based tools by 14.6% in recovering types for both function arguments and variables. Our ablation studies show that GSM improves type inference accuracy by 33%.},
    booktitle = {Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
    pages = {690-702},
    numpages = {13},
    keywords = {Machine Learning for Program Analysis, Reverse Engineering, Transfer Learning, Type Inference},
    location = {Athens, Greece},
    series = {ESEC/FSE 2021}
}

@inproceedings{bib:divine,
    author = {Balakrishnan, Gogul and Reps, Thomas},
    title = {DIVINE: Discovering Variables in Executables},
    year = {2007},
    isbn = {9783540697350},
    publisher = {Springer-Verlag},
    address = {Berlin, Heidelberg},
    abstract = {This paper addresses the problem of recovering variable-like entities when analyzing executables in the absence of debugging information. We show that variable-like entities can be recovered by iterating Value-Set Analysis (VSA), a combined numeric-analysis and pointer-analysis algorithm, and Aggregate Structure Identification, an algorithm to identify the structure of aggregates. Our initial experiments show that the technique is successful in correctly identifying 88% of the local variables and 89% of the fields of heap-allocated objects. Previous techniques recovered 83% of the local variables, but 0% of the fields of heap-allocated objects. Moreover, the values computed by VSA using the variables recovered by our algorithm would allow any subsequent analysis to do a better job of interpreting instructions that use indirect addressing to access arrays and heap-allocated data objects: indirect operands can be resolved better at 4% to 39% of the sites of writes and up to 8% of the sites of reads. (These are the memory-access operations for which it is the most difficult for an analyzer to obtain useful results.).},
    booktitle = {Proceedings of the 8th International Conference on Verification, Model Checking, and Abstract Interpretation},
    pages = {1-28},
    numpages = {28},
    location = {Nice, France},
    series = {VMCAI'07}
}

@article{bib:type-learning-binaries-applications,
    author = {Xu, Zhiwu and Wen, Cheng and Qin, Shengchao},
    year = {2018},
    month = {12},
    pages = {1-20},
    title = {Type Learning for Binaries and Its Applications},
    volume = {PP},
    journal = {IEEE Transactions on Reliability},
    doi = {10.1109/TR.2018.2884143}
}

@inproceedings{bib:malware-obfuscation-techniques,
    author = {You, Ilsun and Yim, Kangbin},
    year = {2010},
    month = {11},
    pages = {297-300},
    title = {Malware Obfuscation Techniques: A Brief Survey},
    booktitle = {Proceedings - 2010 International Conference on Broadband, Wireless Computing Communication and Applications, BWCCA 2010},
    doi = {10.1109/BWCCA.2010.85}
}

@article{bib:practical-analysis-stripped-binary-code,
    author = {Harris, Laune and Miller, Barton},
    year = {2005},
    month = {12},
    pages = {63-68},
    title = {Practical analysis of stripped binary code},
    volume = {33},
    journal = {SIGARCH Computer Architecture News},
    doi = {10.1145/1127577.1127590}
}

@inproceedings{bib:how-far-weve-come,
    author = {Liu, Zhibo and Wang, Shuai},
    title = {How Far We Have Come: Testing Decompilation Correctness of C Decompilers},
    year = {2020},
    isbn = {9781450380089},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3395363.3397370},
    doi = {10.1145/3395363.3397370},
    abstract = {A C decompiler converts an executable (the output from a C compiler) into source code. The recovered C source code, once recompiled, will produce an executable with the same functionality as the original executable. With over twenty years of development, C decompilers have been widely used in production to support reverse engineering applications, including legacy software migration, security retrofitting, software comprehension, and to act as the first step in launching adversarial software exploitations. As the paramount component and the trust base in numerous cybersecurity tasks, C decompilers have enabled the analysis of malware, ransomware, and promoted cybersecurity professionalsâ€™ understanding of vulnerabilities in real-world systems. In contrast to this flourishing market, our observation is that in academia, outputs of C decompilers (i.e., recovered C source code) are still not extensively used. Instead, the intermediate representations are often more desired for usage when developing applications such as binary security retrofitting. We acknowledge that such conservative approaches in academia are a result of widespread and pessimistic views on the decompilation correctness. However, in conventional software engineering and security research, how much of a problem is, for instance, reusing a piece of simple legacy code by taking the output of modern C decompilers? In this work, we test decompilation correctness to present an up-to-date understanding regarding modern C decompilers. We detected a total of 1,423 inputs that can trigger decompilation errors from four popular decompilers, and with extensive manual effort, we identified 13 bugs in two open-source decompilers. Our findings show that the overly pessimistic view of decompilation correctness leads researchers to underestimate the potential of modern decompilers; the state-of-the-art decompilers certainly care about the functional correctness, and they are making promising progress. However, some tasks that have been studied for years in academia, such as type inference and optimization, still impede C decompilers from generating quality outputs more than is reflected in the literature. These issues rarely receive enough attention and can lead to great confusion that misleads users.},
    booktitle = {Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis},
    pages = {475-487},
    numpages = {13},
    keywords = {Reverse Engineering, Software Testing, Decompiler},
    location = {Virtual Event, USA},
    series = {ISSTA 2020}
}

@inbook{bib:sre,
    author="Cipresso, Teodoro
    and Stamp, Mark",
    editor="Stavroulakis, Peter
    and Stamp, Mark",
    title="Software Reverse Engineering",
    bookTitle="Handbook of Information and Communication Security",
    year="2010",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="659--696",
    abstract="Software reverse engineering (SRE) is the practice of analyzing a software system, either in whole or in part, to extract design and implementation information. A typical SRE scenario would involve a software module that has worked for years and carries several rules of a business in its lines of code; unfortunately the source code of the application has been lost -- what remains is ``native'' or ``binary'' code. Reverse engineering skills are also used to detect and neutralize viruses and malware, and to protect intellectual property. Computer programmers proficient in SRE will be needed should software components like these need to be maintained, enhanced, or reused. It became frightfully apparent during the Y2K crisis that reverse engineering skills were not commonly held amongst programmers. Since that time, much research has been under way to formalize just what types of activities fall into the category of reverse engineering, so that these skills could be taught to computer programmers and testers. To help address the lack of SRE education, several peer-reviewed articles on SRE, software re-engineering, software reuse, software maintenance, software evolution, and software security were gathered with the objective of developing relevant, practical exercises for instructional purposes. The research revealed that SRE is fairly well described and all related activities mostly fall into one of two categories: software-development-related and software-security-related. Hands-on reversing exercises were developed in the spirit of these two categories with the goal of providing a baseline education in reversing both Wintel machine code and Java bytecode.",
    isbn="978-3-642-04117-4",
    doi="10.1007/978-3-642-04117-4_31",
    url="https://doi.org/10.1007/978-3-642-04117-4_31"
}

@inproceedings{bib:disassembly-challenges,
    title={A Binary Rewriting Defense Against Stack based Buffer Overflow Attacks},
    author={Manish Prasad and Tzi-cker Chiueh},
    booktitle={USENIX Annual Technical Conference, General Track},
    year={2003}
}

@misc{bib:technique-for-decompiling-binary-code-for-assurance,
    author="W. Klieber",
    title="A Technique for Decompiling Binary Code for Software Assurance and Localized Repair",
    month="Oct. 11,",
    year={2021},
    howpublished="Carnegie Mellon University's Software Engineering Institute Blog",
    url="http://insights.sei.cmu.edu/blog/a-technique-for-decompiling-binary-code-for-software-assurance-and-localized-repair/"
}

@online{bib:dwarf,
    author = {{DWARF Standards Committee}},
    title = {The DWARF Debugging Standard},
    url = {https://dwarfstd.org/},
    year = {2022}
}

@online{bib:ghidra,
    author = {{National Security Agency (NSA)}},
    title = {Ghidra},
    url = {https://ghidra-sre.org/},
    year = {2022}
}

@inproceedings{bib:sok-x86-disassembly,
    author={Pang, Chengbin and Yu, Ruotong and Chen, Yaohui and Koskinen, Eric and Portokalidis, Georgios and Mao, Bing and Xu, Jun},
    booktitle={2021 IEEE Symposium on Security and Privacy (SP)}, 
    title={SoK: All You Ever Wanted to Know About x86/x64 Binary Disassembly But Were Afraid to Ask}, 
    year={2021},
    pages={833-851},
    doi={10.1109/SP40001.2021.00012}
}

@misc{bib:pyelftools,
    author = {Bendersky, Eli},
    title = {pyelftools},
    year = {2022},
    publisher = {GitHub},
    journal = {GitHub repository},
    url = {https://github.com/eliben/pyelftools},
    commit = {8a74c8f9ca466de0738b1e94394aac494ff3db39}
}

@misc{bib:issues-debugging-inspecting-optimized-binaries,
    author = {Cohen, William},
    title = {Possible issues with debugging and inspecting compiler-optimized binaries},
    year = {2020},
    publisher = {Red Hat, Inc.},
    url = {https://developers.redhat.com/blog/2020/03/13/possible-issues-with-debugging-and-inspecting-compiler-optimized-binaries#debugging_is_hard}
}

@inproceedings{bib:tie,
    title={TIE: Principled Reverse Engineering of Types in Binary Programs},
    author={Jonghyup Lee and Thanassis Avgerinos and David Brumley},
    booktitle={Network and Distributed System Security Symposium},
    year={2011}
}

@inproceedings{bib:rewards,
    author = {Lin, Zhiqiang and Zhang, Xiangyu and Xu, Dongyan},
    title = {Automatic Reverse Engineering of Data Structures from Binary Execution},
    year = {2010},
    publisher = {CERIAS - Purdue University},
    address = {West Lafayette, IN},
    abstract = {With only the binary executable of a program, it is useful to discover the program's data structures and infer their syntactic and semantic definitions. Such knowledge is highly valuable in a variety of security and forensic applications. Although there exist efforts in program data structure inference, the existing solutions are not suitable for our targeted application scenarios. In this paper, we propose a reverse engineering technique to automatically reveal program data structures from binaries. Our technique, called REWARDS, is based on dynamic analysis. More specifically, each memory location accessed by the program is tagged with a timestamped type attribute. Following the program's runtime data flow, this attribute is propagated to other memory locations and registers that share the same type. During the propagation, a variable's type gets resolved if it is involved in a type-revealing execution point or type sink. More importantly, besides the forward type propagation, REWARDS involves a backward type resolution procedure where the types of some previously accessed variables get recursively resolved starting from a type sink. This procedure is constrained by the timestamps of relevant memory locations to disambiguate variables re-using the same memory location. In addition, REWARDS is able to reconstruct in-memory data structure layout based on the type information derived. We demonstrate that REWARDS provides unique benefits to two applications: memory image forensics and binary fuzzing for vulnerability discovery.},
    booktitle = {Proceedings of the 11th Annual Information Security Symposium},
    articleno = {5},
    numpages = {1},
    location = {West Lafayette, Indiana},
    series = {CERIAS '10}
}

@inproceedings{bib:scalable-variable-datatype-detection,
    author = {ElWazeer, Khaled and Anand, Kapil and Kotha, Aparna and Smithson, Matthew and Barua, Rajeev},
    title = {Scalable Variable and Data Type Detection in a Binary Rewriter},
    year = {2013},
    isbn = {9781450320146},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2491956.2462165},
    doi = {10.1145/2491956.2462165},
    abstract = {We present scalable static analyses to recover variables, data types, and function prototypes from stripped x86 executables (without symbol or debug information) and obtain a functional intermediate representation (IR) for analysis and rewriting purposes. Our techniques on average run 352X faster than current techniques and still have the same precision. This enables analyzing executables as large as millions of instructions in minutes which is not possible using existing techniques. Our techniques can recover variables allocated to the floating point stack unlike current techniques. We have integrated our techniques to obtain a compiler level IR that works correctly if recompiled and produces the same output as the input executable. We demonstrate scalability, precision and correctness of our proposed techniques by evaluating them on the complete SPEC2006 benchmarks suite.},
    booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
    pages = {51-60},
    numpages = {10},
    keywords = {binary rewriting, type recovery, variable recovery, reverse engineering},
    location = {Seattle, Washington, USA},
    series = {PLDI '13}
}

@inproceedings{bib:retypd,
    author = {Noonan, Matt and Loginov, Alexey and Cok, David},
    title = {Polymorphic Type Inference for Machine Code},
    year = {2016},
    isbn = {9781450342612},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2908080.2908119},
    doi = {10.1145/2908080.2908119},
    abstract = {For many compiled languages, source-level types are erased very early in the compilation process. As a result, further compiler passes may convert type-safe source into type-unsafe machine code. Type-unsafe idioms in the original source and type-unsafe optimizations mean that type information in a stripped binary is essentially nonexistent. The problem of recovering high-level types by performing type inference over stripped machine code is called type reconstruction, and offers a useful capability in support of reverse engineering and decompilation. In this paper, we motivate and develop a novel type system and algorithm for machine-code type inference. The features of this type system were developed by surveying a wide collection of common source- and machine-code idioms, building a catalog of challenging cases for type reconstruction. We found that these idioms place a sophisticated set of requirements on the type system, inducing features such as recursively-constrained polymorphic types. Many of the features we identify are often seen only in expressive and powerful type systems used by high-level functional languages. Using these type-system features as a guideline, we have developed Retypd: a novel static type-inference algorithm for machine code that supports recursive types, polymorphism, and subtyping. Retypd yields more accurate inferred types than existing algorithms, while also enabling new capabilities such as reconstruction of pointer const annotations with 98% recall. Retypd can operate on weaker program representations than the current state of the art, removing the need for high-quality points-to information that may be impractical to compute.},
    booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
    pages = {27-41},
    numpages = {15},
    keywords = {Polymorphism, Pushdown Automata, Static Analyiss, Binary Analysis, Reverse Engineering, Type Systems},
    location = {Santa Barbara, CA, USA},
    series = {PLDI '16}
}

@online{bib:ida,
    author = {{Hex-Rays}},
    title = {IDA Pro},
    url = {https://www.hex-rays.com/ida-pro/},
    year = {2022}
}

@online{bib:artiste,
    publisher={IMDEA Software Institute},
    title={ARTISTE: Automatic Generation of Hybrid Data Structure Signatures from Binary Code Executions},
    author={Juan Caballero and Gustavo Grieco and Mark Marron and Zhiqiang Lin and David I. Urbina},
    year={2012},
    address={Madrid, Spain}
}

@online{bib:jeb,
    author = {{PNF Software}},
    title = {JEB},
    url = {https://www.pnfsoftware.com/jeb/},
    year = {2022}
}

@inproceedings{bib:cati,
    author={Chen, Ligeng and He, Zhongling and Mao, Bing},
    booktitle={2020 50th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
    title={CATI: Context-Assisted Type Inference from Stripped Binaries},
    year={2020},
    pages={88-98},
    doi={10.1109/DSN48063.2020.00028}
}

@inproceedings{bib:metrics-effectiveness-decompilers,
    author={Naeem, Nomair A. and Batchelder, Michael and Hendren, Laurie},
    booktitle={15th IEEE International Conference on Program Comprehension (ICPC '07)},
    title={Metrics for Measuring the Effectiveness of Decompilers and Obfuscators},
    year={2007},
    pages={253-258},
    doi={10.1109/ICPC.2007.27}
}

@online{bib:retdec,
    author = {Avast},
    title = {RetDec},
    url = {https://github.com/avast/retdec},
    publisher = {GitHub},
    year = {2022}
}
